"""GapSeeker — Autonomous gap detection and remediation helpers.

This module implements the "GapSeeker" flow described in the cathedral
doctrine.  It provides lightweight primitives that can be composed with the
existing Codex automation stack in order to discover gaps (TODO markers,
missing tests, typing errors) and route them through the proper remediation
channels.

The primary collaborators are:

``RepoScanner``
    Crawls a source tree looking for inline TODO/FIXME comments and obvious
    implementation stubs (``raise NotImplementedError``).  The scanner yields
    :class:`GapSignal` instances lazily to avoid blocking daemon loops.

``CoverageReader``
    Normalises coverage telemetry (pytest JSON reports as well as mypy textual
    output) into the same :class:`GapSignal` representation.

``GapReporter``
    Aggregates signals from multiple origins, deduplicates them and produces a
    prioritised list ordered by severity.

``GapAmender``
    Dispatches gaps to either a :class:`SpecAmender` compatible callable or a
    GenesisForge-style scaffold generator.  Each resolution is recorded via a
    :class:`NarratorLink` so that RecoveryLedger and narration pipelines stay
    synchronised.

``GapSeeker``
    Convenience façade that wires the above collaborators together for a
    single sweep.

The implementations intentionally avoid hard-coding SentientOS specific file
layouts in favour of small, testable components that can be orchestrated from
the daemon layer.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Callable, Iterable, Iterator, Mapping, MutableMapping, Sequence

import json
import re

from sentientos.codex_healer import Anomaly, RecoveryLedger

__all__ = [
    "GapSignal",
    "GapResolution",
    "GapResolutionError",
    "RepoScanner",
    "CoverageReader",
    "GapReporter",
    "GapAmender",
    "NarratorLink",
    "GapSeeker",
]


# ---------------------------------------------------------------------------
# Shared data structures


@dataclass(slots=True, frozen=True)
class GapSignal:
    """Normalised representation of a detected gap."""

    path: Path
    line: int
    description: str
    severity: str
    kind: str
    source: str
    metadata: MutableMapping[str, object] = field(default_factory=dict)

    @property
    def identity(self) -> str:
        """Stable identifier used for deduplication."""

        return f"{self.path}:{self.line}:{self.kind}"


@dataclass(slots=True, frozen=True)
class GapResolution:
    """Outcome generated by :class:`GapAmender`."""

    gap: GapSignal
    action: str
    status: str
    payload: Mapping[str, object]


class GapResolutionError(RuntimeError):
    """Raised when a gap cannot be routed to a remediation strategy."""


# ---------------------------------------------------------------------------
# Repo scanning


class RepoScanner:
    """Scan source files for TODO markers and unimplemented stubs."""

    TODO_PATTERN = re.compile(r"\bTODO\b", re.IGNORECASE)
    FIXME_PATTERN = re.compile(r"\bFIXME\b", re.IGNORECASE)
    NOT_IMPLEMENTED_PATTERN = re.compile(r"not\s*implemented", re.IGNORECASE)

    def __init__(
        self,
        root: Path | str,
        *,
        include_globs: Sequence[str] | None = None,
        encoding: str = "utf-8",
    ) -> None:
        self._root = Path(root)
        self._include_globs = tuple(include_globs or ("*.py", "*.md"))
        self._encoding = encoding

    def iter_gaps(self) -> Iterator[GapSignal]:
        """Yield gaps lazily to avoid blocking long running loops."""

        for pattern in self._include_globs:
            for path in sorted(self._root.rglob(pattern)):
                if not path.is_file():
                    continue
                yield from self._scan_file(path)

    def scan(self) -> list[GapSignal]:
        """Collect all gaps into a list."""

        return list(self.iter_gaps())

    def _scan_file(self, path: Path) -> Iterator[GapSignal]:
        try:
            contents = path.read_text(encoding=self._encoding)
        except (OSError, UnicodeDecodeError):
            return

        for number, raw_line in enumerate(contents.splitlines(), start=1):
            stripped = raw_line.strip()
            lowered = stripped.lower()
            metadata: dict[str, object] = {"line_text": stripped}

            if self.TODO_PATTERN.search(raw_line):
                yield GapSignal(
                    path=path,
                    line=number,
                    description=stripped or "TODO marker",
                    severity="medium",
                    kind="todo",
                    source="repo",
                    metadata={**metadata, "match": "todo"},
                )
            if self.FIXME_PATTERN.search(raw_line):
                yield GapSignal(
                    path=path,
                    line=number,
                    description=stripped or "FIXME marker",
                    severity="high",
                    kind="fixme",
                    source="repo",
                    metadata={**metadata, "match": "fixme"},
                )
            if "notimplementederror" in lowered or self.NOT_IMPLEMENTED_PATTERN.search(raw_line):
                yield GapSignal(
                    path=path,
                    line=number,
                    description=stripped or "Unimplemented stub",
                    severity="high",
                    kind="unimplemented",
                    source="repo",
                    metadata={**metadata, "match": "not_implemented"},
                )


# ---------------------------------------------------------------------------
# Coverage telemetry


class CoverageReader:
    """Parse coverage and type-checking outputs into gap signals."""

    def __init__(
        self,
        *,
        coverage_path: Path | None = None,
        mypy_path: Path | None = None,
        encoding: str = "utf-8",
    ) -> None:
        self._coverage_path = Path(coverage_path) if coverage_path else None
        self._mypy_path = Path(mypy_path) if mypy_path else None
        self._encoding = encoding

    def collect(
        self,
        *,
        coverage_report: Mapping[str, object] | None = None,
        mypy_output: Iterable[str] | str | None = None,
    ) -> list[GapSignal]:
        """Return gaps derived from coverage and typing telemetry."""

        coverage_report = coverage_report or self._load_coverage_report()
        mypy_output = mypy_output or self._load_mypy_output()

        gaps: list[GapSignal] = []
        if coverage_report:
            gaps.extend(self._from_pytest_coverage(coverage_report))
        if mypy_output:
            gaps.extend(self._from_mypy_output(mypy_output))
        return gaps

    # ------------------------------------------------------------------
    # Pytest coverage helpers
    def _load_coverage_report(self) -> Mapping[str, object]:
        if self._coverage_path is None or not self._coverage_path.exists():
            return {}
        try:
            raw = self._coverage_path.read_text(encoding=self._encoding)
            return json.loads(raw)
        except (OSError, json.JSONDecodeError):
            return {}

    def _from_pytest_coverage(self, report: Mapping[str, object]) -> list[GapSignal]:
        files = report.get("files")
        if not isinstance(files, Mapping):
            return []
        gaps: list[GapSignal] = []
        for filename, entry in files.items():
            if not isinstance(entry, Mapping):
                continue
            missing = entry.get("missing_lines") or entry.get("missing")
            if not missing:
                continue
            if isinstance(missing, str):
                missing_lines = [int(value) for value in missing.split(",") if value.strip().isdigit()]
            else:
                missing_lines = [int(value) for value in missing if isinstance(value, int)]
            if not missing_lines:
                continue
            line = min(missing_lines)
            description = f"Missing test coverage for lines {', '.join(map(str, missing_lines))}"
            metadata: dict[str, object] = {
                "missing_lines": missing_lines,
                "coverage": entry.get("coverage"),
            }
            gaps.append(
                GapSignal(
                    path=Path(filename),
                    line=line,
                    description=description,
                    severity="high",
                    kind="missing_tests",
                    source="coverage",
                    metadata=metadata,
                )
            )
        return gaps

    # ------------------------------------------------------------------
    # Mypy helpers
    def _load_mypy_output(self) -> list[str]:
        if self._mypy_path is None or not self._mypy_path.exists():
            return []
        try:
            contents = self._mypy_path.read_text(encoding=self._encoding)
        except OSError:
            return []
        return contents.splitlines()

    def _from_mypy_output(self, output: Iterable[str] | str) -> list[GapSignal]:
        if isinstance(output, str):
            lines = output.splitlines()
        else:
            lines = list(output)
        gaps: list[GapSignal] = []
        pattern = re.compile(r"^(?P<path>[^:]+):(\d+):(?:(\d+):)?\s*(?P<level>error|note|warning):\s*(?P<message>.+)$")
        for raw in lines:
            match = pattern.match(raw.strip())
            if not match:
                continue
            level = match.group("level")
            if level != "error":
                continue
            path = Path(match.group("path"))
            line = int(match.group(2))
            message = match.group("message").strip()
            gaps.append(
                GapSignal(
                    path=path,
                    line=line,
                    description=f"mypy: {message}",
                    severity="high",
                    kind="type_error",
                    source="mypy",
                    metadata={"message": message},
                )
            )
        return gaps


# ---------------------------------------------------------------------------
# Gap reporting


class GapReporter:
    """Aggregate and prioritise gap signals."""

    _SEVERITY_ORDER = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}

    def aggregate(self, *sources: Iterable[GapSignal]) -> list[GapSignal]:
        """Merge gaps from all sources, deduplicating on identity."""

        merged: dict[str, GapSignal] = {}
        for source in sources:
            for signal in source:
                existing = merged.get(signal.identity)
                if existing is None:
                    merged[signal.identity] = signal
                    continue
                if self._rank(signal.severity) < self._rank(existing.severity):
                    merged[signal.identity] = signal
        ordered = sorted(merged.values(), key=lambda gap: (self._rank(gap.severity), str(gap.path), gap.line))
        return ordered

    def _rank(self, severity: str) -> int:
        return self._SEVERITY_ORDER.get(severity, len(self._SEVERITY_ORDER))


# ---------------------------------------------------------------------------
# Narration bridge


class NarratorLink:
    """Persist gap resolutions to RecoveryLedger and produce summaries."""

    _SUMMARY_LABELS = {
        "missing_tests": ("found and filled", "missing test", "missing tests"),
        "type_error": ("patched", "type error", "type errors"),
        "todo": ("addressed", "TODO", "TODOs"),
        "fixme": ("patched", "FIXME", "FIXMEs"),
        "unimplemented": ("implemented", "stub", "stubs"),
    }

    def __init__(
        self,
        ledger: RecoveryLedger | None = None,
        *,
        on_record: Callable[[GapResolution], None] | None = None,
    ) -> None:
        self._ledger = ledger
        self._on_record = on_record
        self._history: list[GapResolution] = []

    def record(self, resolution: GapResolution) -> None:
        self._history.append(resolution)
        if self._ledger is not None:
            anomaly = Anomaly(
                kind="gap",
                subject=resolution.gap.identity,
                details={
                    "action": resolution.action,
                    "status": resolution.status,
                    "kind": resolution.gap.kind,
                    "path": str(resolution.gap.path),
                    "line": resolution.gap.line,
                },
            )
            details = {
                "description": resolution.gap.description,
                "metadata": dict(resolution.gap.metadata),
            }
            details.update(resolution.payload)
            self._ledger.log(resolution.status, anomaly=anomaly, details=details)
        if self._on_record:
            self._on_record(resolution)

    def summary(self) -> str:
        successful = [
            item
            for item in self._history
            if item.status in {"amendment", "scaffolded"}
        ]
        if not successful:
            return "No gap closures recorded."
        grouped: dict[tuple[str, str], int] = {}
        for resolution in successful:
            module = self._module_name(resolution.gap.path)
            key = (resolution.gap.kind, module)
            grouped[key] = grouped.get(key, 0) + 1
        snippets: list[str] = []
        for (kind, module), count in sorted(grouped.items(), key=lambda item: (item[0][0], item[0][1])):
            verb, singular, plural = self._SUMMARY_LABELS.get(kind, ("resolved", "gap", "gaps"))
            noun = singular if count == 1 else plural
            snippets.append(f"{verb} {count} {noun} in {module}")
        joined = " and ".join(snippets)
        return f"I {joined}."

    @staticmethod
    def _module_name(path: Path) -> str:
        stem = path.stem
        parts = [part for part in stem.split("_") if part]
        if not parts:
            return stem or "module"
        return "".join(part.capitalize() for part in parts)

    @property
    def history(self) -> list[GapResolution]:
        return list(self._history)


# ---------------------------------------------------------------------------
# Gap amendment routing


class GapAmender:
    """Route gaps to SpecAmender or GenesisForge style handlers."""

    GENESIS_KINDS = {"missing_tests", "uncovered_branch", "uncovered_flow"}

    def __init__(
        self,
        *,
        spec_handler: Callable[[GapSignal], Mapping[str, object]],
        genesis_handler: Callable[[GapSignal], Mapping[str, object]],
        narrator: NarratorLink | None = None,
    ) -> None:
        self._spec_handler = spec_handler
        self._genesis_handler = genesis_handler
        self._narrator = narrator

    def process(self, gaps: Iterable[GapSignal]) -> list[GapResolution]:
        resolutions: list[GapResolution] = []
        for gap in gaps:
            handler: Callable[[GapSignal], Mapping[str, object]]
            action: str
            status: str
            payload: Mapping[str, object]
            try:
                if gap.kind in self.GENESIS_KINDS:
                    handler = self._genesis_handler
                    action = "genesis"
                    status = "scaffolded"
                else:
                    handler = self._spec_handler
                    action = "spec"
                    status = "amendment"
                payload = handler(gap)
            except GapResolutionError as exc:
                action = "spec" if gap.kind not in self.GENESIS_KINDS else "genesis"
                status = "unfillable"
                payload = {"reason": str(exc)}
            except Exception as exc:  # pragma: no cover - defensive guard
                action = "spec" if gap.kind not in self.GENESIS_KINDS else "genesis"
                status = "unfillable"
                payload = {"reason": str(exc)}
            resolution = GapResolution(gap=gap, action=action, status=status, payload=payload)
            if self._narrator is not None:
                self._narrator.record(resolution)
            resolutions.append(resolution)
        return resolutions


# ---------------------------------------------------------------------------
# High level façade


class GapSeeker:
    """Wire the GapSeeker modules into a single sweep."""

    def __init__(
        self,
        scanner: RepoScanner,
        coverage_reader: CoverageReader,
        reporter: GapReporter,
        amender: GapAmender,
    ) -> None:
        self._scanner = scanner
        self._coverage_reader = coverage_reader
        self._reporter = reporter
        self._amender = amender

    def run_once(
        self,
        *,
        coverage_report: Mapping[str, object] | None = None,
        mypy_output: Iterable[str] | str | None = None,
    ) -> list[GapResolution]:
        repo_gaps = self._scanner.iter_gaps()
        telemetry_gaps = self._coverage_reader.collect(
            coverage_report=coverage_report,
            mypy_output=mypy_output,
        )
        queue = self._reporter.aggregate(repo_gaps, telemetry_gaps)
        return self._amender.process(queue)

